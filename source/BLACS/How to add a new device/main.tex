\documentclass[12pt]{article}
\include{pythonlisting}
\usepackage{setspace}
\usepackage[margin=1.5cm]{geometry}


\begin{document}\title{How to add a new type of hardware device to BLACS}
\author{Philip Starkey}
\date{\today}
\maketitle
\setstretch{1.2}
\section{Introduction}
This tutorial covers the basics of adding a new hardware device type to BLACS. Existing device types include the PulseBlaster, NovatechDDS9m, NI PCIe 6363 and NI PCI 6733. These classes are used by BLACS to generate the unique tab for each device on the BLACS front panel. Adding support for your device to BLACS does not add support to labscript, which will also need to be done if you wish to use the device in a buffered sequence (see **TO BE ADDED IN LATER**). If your device is never to be used in a buffered sequence, you may instead wish to implement it as a virtual device (see ** TO BE ADDED IN LATER**).

This tutorial assumes a working knowledge of Python, PyGTK and Glade. If are not familiar with one or more of these, please attempt a tutorial on the subject before continuing with this!

\section{The Glade Interface}\label{glade interface}
The first step is to roughly design the interface for your device in Glade. The design of your interface can be as simple or as complex as you like. 

The backend of BLACS only requires that you conform to one rule for your interface. Anything you want to behave as a digital out should be represented by a widget that can be linked to a GtkAction (this is generally a togglebutton or a checkbox).

Anything you want to behave as an analog out should be represented by a widget that can be linked to a GtkAdjustment (usually a GtkSpinButton) and should have a corresponding GtkComboBox for changing the units of the value shown in the GtkSpinButton.

Also note that internally within BLACS and Labscript, we represent a DDS as a collection of 3 analog outs (one for frequency, amplitude and phase), so it is recommended to follow this pattern when creating an interface for a DDS device. In general, most interfaces can be broken down into a combination of digital outputs (a part of the device with only two states) and analog outputs (a part of the device which can take any value between a maximum and minimum value, often with a particular quantisation).

\textbf{As of Feb 08, 2012, BLACS does not override the GtkSpinButton properties such as \texttt{digits} and \texttt{climb rate}. It will however add it's own GtkAdjustment to the widget, so you are not required to do this yourself in glade.}

\subsection{The GtkComboBox for unit selection}\label{glade unit selection}
For each \texttt{GtkSpinButton}, you should have a \texttt{GtkCombobox} located nearby for displaying the unit, and switching between different unit calibrations.

You will also need to create a \texttt{GtkListStore} \textbf{for each} unit selection \texttt{GtkCombobox} and then link them to the \texttt{GtkCombobox}'s appropriately. The list store should have one column called \texttt{unit} of type \texttt{gchararray}. Each \texttt{GtkCombobox} will then need a \texttt{GtkCellRendererText} child for which the \texttt{text} property is linked to the \texttt{unit} column of the \texttt{GtkListStore}

\section{Creating the Device Class}\label{creating class}
All device classes as stored in pythonlib/BLACS/hardware\_interfaces. You should create a new file for your device in this folder, with an appropriate name (we shall refer to the name in this tutorial as \texttt{pulseblaster.py}).

The first thing you need to do in your empty python file is import the required packages and classes. The code below imports gtk and the BLACS backend classes for handling various output types. 
The final line imports the BLACS backend for the tab state machine. We'll cover these more as we go.
\begin{python}
import gtk
from output_classes import AO, DO, DDS
from tab_base_classes import Tab, Worker, define_state
\end{python}

Next we need to define two classes. The first class will handle the GUI, and related events. The second will handle the communication with the actual hardware. The first class name (hence forth known as the device class) should match (ignoring case) the device class shown in the entry in the connection table for an instance of your device. It should also be the same name as your python file. You may call the second class (hence forth known as the worker class) whatever you wish, though it is advisable to use something understandable!

In this tutorial we will use \texttt{pulseblaster} and \texttt{PulseblasterWorker} as our class names. 

\begin{python}
class pulseblaster(Tab):
    pass
	
class PulseblasterWorker(Worker):
    pass
\end{python}

\textbf{Note:} We have used \texttt{pass} here as a placeholder. You can assume that the \texttt{pass} statements will be removed once the tutorial inserts code at the same indentation level.
\newpage
\subsection{The Worker Class}
The worker class is used solely to communicated with the hardware for our device. It exists to separate out the code, modules, dll's, etc. from the GUI to provide better stability to the system. The worker class is instantiated inside a separate process (reffered to from now on as the worker process), which can be restarted by the user if the device becomes unresponsive. Upon restart, all libraries are completely reloaded as they are only loaded within the worker process. This allows the system to recover from errors in 3rd party API's without the need to restart the entire control system.

The worker class consists of methods which can be executed by the state machine. In your device class you can call:
\begin{python}
self.queue_work('some_function',arg1,arg2,kwrd1=arg3)
\end{python}
and this will call the function called \texttt{some\_function} with arguments \texttt{arg1,arg2,kwrd1=arg3} in the worker class. This is covered in more detail in section \ref{device_class_state_machine}.

\subsubsection{The \texttt{init} method}
The init method in the worker class is special for two reasons. The first is that it is not called \texttt{\_\_init\_\_} as you would expect. This is because we don't want to override the \texttt{\_\_init\_\_} method in class \texttt{Worker},  which is essential for successful operation.

The second is that this is the function in which you import the modules, classes, etc. that you wish to access from within the worker class. They are imported here, within the class, so that they only exist within the worker process, and not within the BLACS process. This allows modules to be completely unloaded from the system when the worker process is restarted. This allows recovery of the programming library without the need to completely restart the program (a technique not seen in any other control system to our knowledge).

If you wish to import a module (for example \texttt{h5py}), use the following code:
\begin{python}
class PulseblasterWorker(Worker):
    def init(self):
        global h5py; import h5py
\end{python}

If you wish to import something from within a module (for example \texttt{spinapi}), you can use:
\begin{python}
        exec 'from spinapi import *' in globals()
\end{python}

You can also set the default values for any class attributes in the \texttt{init} method. For instance:
\begin{python}
        self.smart_cache = {}
\end{python}

If you wish to pass in variables, at instantiation, to your worker class, you can do so, and it is document in section \ref{device_class_init}.

\subsubsection{Worker Class States}
As covered in section \ref{device_class_state_machine} you can ask the tabs state machine to execute functions within the worker class. These functions can take arguments and keyword arguments as a normal function would, however the arguments must be able to be placed in a Python Queue. Objects with instance methods cannot be placed in a queue, and so can not be passed to a function you wish to call from the state machine.

In general you will have at least 3 functions within your worker class. One to initialise the device, one to handle an update to the devices output in software timed mode (otherwise known as \texttt{static mode}) and one to handle the programming of the device for the hardware timed mode (otherwise known as \texttt{buffered mode}). You may also want functions for exiting the buffered mode (via an abort, or end at the end of the run), checking the status of the device, etc.

Examples of such functions can be seen in any of the existing hardware interface worker classes.

\newpage
\subsection{The Device Class}\label{device_class}

\subsubsection{The state machine}\label{device_class_state_machine}
The device class contains a state machine which regulates the interprocess communication between the worker process and the GUI process, as well as making sure that the GTK event/signal based architecture is transformed into a deterministic system. 

Most of the state machine architecture is hidden within the \texttt{Tab} class. Any method in the device class prefixed with \texttt{@define\_state} will be queued up appropriately in the state machine. An example is shown below:
\begin{python}
    @define_state
    def start(self,widget=None):
        # some code follows
        time.sleep(5)
\end{python}

Note that if we call this method from within our code, E.g.:
\begin{python}
    def foo(self):
        self.start() # This function call returns immediately
\end{python}
the call to \texttt{start} returns immediately. Some time in the future, the method start will be executed, and the thread will sleep for 5 seconds as expected.

This means that calls to state machine methods (E.g. \texttt{start}) cannot return parameters in the conventional way. It is expected that state machine methods will be called upon a GTK event (in which case you will never need to return anything from your state) or from another thread (in which case you can use a Python Queue to block the calling thread until your state machine method puts the returns values in the queue)

As mentioned, state machine methods are designed to interact with the worker process. You can call functions within your worker class with the following code:
\begin{python}
    @define_state
    def start(self,widget=None):
        self.queue_work('foo')
\end{python}

If you wish to pass arguments to your method, you can instead call something similar to
\begin{python}
        self.queue_work('foo',1,5,x=3)
\end{python}
This will call the method \texttt{foo} with the arguments \texttt{1,5,3} in the worker process.

It is important to note that you cannot pass objects as arguments to a worker class method. The arguments must be able to be placed into a Python Queue.

Note that the worker process function is not executed until the state machine function ends. Thus in the following example 
\begin{python}
    @define_state
    def start(self,widget=None):
        x = 1
        self.queue_work('foo',x)
        x = 2
        print x
\end{python}
\texttt{'2'} will be printed before the method \texttt{foo} is executed. Since \texttt{x} is an integer, \texttt{foo} will be passed \texttt{'1'} as it's only argument. It is recommended that you call \texttt{self.queue\_work} at the end of your state machine function to avoid confusion.

If you wish to execute some further code once the worker class method has been executed, you can use the \texttt{self.do\_after} method. For example:
\begin{python}
    @define_state
    def start(self,widget=None):
        x = 1
        self.queue_work('foo',x)
        self.do_after('leave_foo',x)
        
    def leave_foo(self,x,_results):
        print x # prints 1
        print _results
\end{python}
The last argument passed to the method called by \texttt{do\_after} is \texttt{\_results} which contains a tuple of values returned by the worker class method called by \texttt{queue\_work}. Note that the method called by \texttt{do\_after} does \textbf{not} have \texttt{@define\_state} written above it's definition.

\subsubsection{Class attributes}\label{device_class_attributes}
It is necessary to define the capabilities of the device as follows:
\begin{python}
class pulseblaster(Tab):
    # Channel Capabilities
    # You must follow the naming convention shown here as BLACS uses them to save
    # the state of the AO/DO/DDS channels in your device.
    num_DDS = 2
    num_DO = 4 
    # If one is zero, you may omit it.
    # num_AO = 0
    
    # It is also a good idea to define hardware limits for your output channels here
    # The names you give these variables are arbitrary and are for your use only,
    # though it is recommended to stay consistent with these names
    base_units = {'freq':'MHz',     'amp':'Vpp', 'phase':'Degrees'}
    base_min =   {'freq':0.0000003, 'amp':0.0,   'phase':0}
    base_max =   {'freq':150.0,     'amp':1.0,   'phase':360}
    base_step =  {'freq':1,         'amp':0.01,  'phase':1}
\end{python}

\subsubsection{The \texttt{\_\_init\_\_} method}\label{device_class_init}
The \texttt{\_\_init\_\_} method definition is as follows:
\begin{python}
    # notebook: The notebook in which this tab is located. 
    #           You shouldn't need to use this, except to pass
    #           it to the Tab __init__ method
    #
    # settings: This is a dictionary that contains the 'device_name'
    #           The 'connection_table' object for BLACS
    #           The 'saved_data' returned by self.get_save_data() on last exit
    #           The 'front_panel_settings' which contains all saved data for
    #           attached DO/AO/DDS channels
    #
    # restart: This is True only if the device tab has been restarted by the user
    def __init__(self,notebook,settings,restart=False):
\end{python}

One of the first things to do in the \texttt{\_\_init\_\_} method is to instantiate the \texttt{Tab} base class via:
\begin{python}
		# PulseblasterWorker is the class name for the device worker class 
		# you have defined previously.
        Tab.__init__(self,PulseblasterWorker,notebook,settings)
\end{python}
You can also pass an optional parameter to this function, \texttt{workerargs=\{\}}. The keys in this dictionary will be turned into instance variables of the worker class whose value matches the value of the dictionary. If you wish to pass your own queue to the worker process, this is where you must do it, and an example can be seen in the \texttt{ni\_pcie\_6363} class.

You will probably also want to save the settings dictionary and device name as attributes. Now is also a good time to create some other attributes you will need later:
\begin{python}
        self.settings = settings
        self.device_name = settings['device_name']
        self.static_mode = True
        self.destroy_complete = False
\end{python}

Now we want to build our GUI from the glade file. We do that by calling:
\begin{python}
        # Create the PyGTK Builder:
        self.builder = gtk.Builder()
        self.builder.add_from_file('hardware_interfaces/your_glade_file.glade')
        # Connect signals to methods in this class
        self.builder.connect_signals(self)
\end{python}
This code also connects any signals you have defined in your glade file to methods within this class. If you do add any signals, make sure you remember to define the methods too!

You can now pull out references to the GTK widgets you placed in your glade file via the names you gave them in glade. You will need to at least get a reference to the GtkScrolledWindow (the top most widget) in your glade file. For example, we have called the top most widget \texttt{toplevel} in \texttt{pulseblaster.glade}, so we would call in the \texttt{\_\_init\_\_} method:
\begin{python} 
        self.toplevel = self.builder.get_object('toplevel')
\end{python}
Any other 'one off' widgets you wish to access and change their content programmatically can be done in a similar fashion.

We now move on to initialising the objects which will handle the widgets for the AO/DO/DDS channels of your device. Depending on the capabilities of your device, you will need to instantiate the following lists (naming convention must be followed):
\begin{python}
        self.dds_outputs = []
        self.digital_outs = []
        self.analog_outs = []
\end{python}

You will now want to loop over the channels for a particular output type. We will give the example for \texttt{DDS}'s here, as this involves making an internal \texttt{AO} object for each of the frequency, amplitude and phase components of the DDS.

Here we loop over the number of DDS channels for the device, and generate a unique name, within this device instance, for each channel. We then get the connection table entry object, and use it to find the channel name if it exists. It is important that the channel name be set to \texttt{-} if it is not in the connection table.
\begin{python}
        for i in range(self.num_DDS):
            # Generate a unique channel name (unique to the device instance,
            # it does not need to be unique to BLACS)
            channel = 'DDS %d'%i
            
            # Get the connection table entry object
            conn_table_entry = self.settings['connection_table'].find_child(
                self.settings['device_name'],'dds %d'%i)
                
            # Get the name of the channel
            # If no name exists, it MUST be set to '-'
            name = conn_table_entry.name if conn_table_entry else '-'
            
            # Set the label to reflect the connected channels name:
            self.builder.get_object('channel_%d_label'%i).set_text(
                channel + ' - ' + name)
\end{python}  

We now loop over the frequency, phase, and amplitude sections of the DDS, and we will create an \texttt{AO} object for each which we will later use to make a \texttt{DDS object}. First however we must get the calibration details for each sub channel from the connection table, and the widgets for each sub channel from the glade file.
\begin{python}
            # Loop over freq,amp,phase and create AO objects for each
            ao_objects = {}
            sub_chnl_list = ['freq','amp','phase']
            for sub_chnl in sub_chnl_list:
                calib = None
                calib_params = {}
                
                # find the calibration details for this subchannel
                # TODO: Also get their min/max values
                if conn_table_entry:
                	sub_chnl_name = conn_table_entry.name+'_'+sub_chnl
                    if sub_chnl_name in conn_table_entry.child_list:
                        sub_chnl_entry = conn_table_entry.child_list[sub_chnl_name]
                        if sub_chnl_entry != "None":
                            calib = sub_chnl_entry.calibration_class
                            calib_params =
                                eval(sub_chnl_entry.calibration_parameters)
                
                # Get the subchannel (eq freq) widget from the glade file
                spinbutton = self.builder.get_object(sub_chnl+'_chnl_%d'%i)
                # Get the unit selection for the subchannel widget
                unit_selection = self.builder.get_object(sub_chnl+'_unit_chnl_%d'%i)
\end{python}

We then create the AO object. Note that we pass in a function as the 8th argument (\texttt{self.program\_static}). This function is covered in section \ref{device_class_program_static} and can be given a different name, just make sure you pass the correct function to the \texttt{AO} and \texttt{DO} objects.
\begin{python}
                # Make output object:
                ao_objects[sub_chnl] = AO(name+'_'+sub_chnl, 
                                          channel+'_'+sub_chnl, 
                                          spinbutton, 
                                          unit_selection, 
                                          calib, 
                                          calib_params, 
                                          self.base_units[sub_chnl], 
                                          self.program_static, 
                                          self.base_min[sub_chnl], 
                                          self.base_max[sub_chnl], 
                                          self.base_step[sub_chnl])
\end{python}

We then update the values and settings of this object to the previously saved state:
\begin{python}
                # Set default values:
                ao_objects[sub_chnl].update(settings)
\end{python}

We can then instantiate the \texttt{DO} object for the DDS gate (which is a lot simpler than the \texttt{AO} objects!) and add them to our \texttt{dds\_outputs} list:
\begin{python}
            # Get the widgets for the gate
            gate_togglebutton = self.builder.get_object('active_chnl_%d'%i)        
            # Make the gate DO object            
            gate = DO(name+'_gate', 
                      channel+'_gate', 
                      gate_togglebutton, 
                      self.program_static)
            # update the gate value based on saved value
            if 'DDS %d_gate'%i in settings['front_panel_settings']:
                gate.set_state(
                   settings['front_panel_settings'][channel+'_gate']['base_value'],
                   program=False)
                    
                # TODO: Set lock state
                    
            # Construct the DDS object and store for later access:
            self.dds_outputs.append(DDS(ao_objects['freq'],
                                        ao_objects['amp'],
                                        ao_objects['phase'],
                                        gate))
\end{python}




\subsubsection{The \texttt{get\_save\_data} method} \label{device_class_get_save_data}
This function provides an interface for saving tab specific data upon exiting BLACS. The data becomes available to the tab during the \texttt{\_\_init\_\_} method in the \texttt{settings['saved\_data']} variable (see section \ref{device_class_init}).

This method should return a dictionary of data to be saved. The dictionary should satisfy the following condition:
\begin{python}
save_data = {'key':value} # Dictionary of data to save

eval(repr(save_data)) == save_data # This expression must be true
\end{python}

We finish by adding the toplevel widget in our glade file to the \texttt{GtkViewport} provided by the \texttt{Tab} base class and queuing up any initialisation functions we want (for instance \texttt{program\_static} and/or a device specific initialisation state):

\begin{python}
        # Insert our GUI into the viewport provided by BLACS:
        self.viewport.add(self.toplevel)
        
        # Initialise the Pulseblaster:
        self.initialise_pulseblaster()
        
        # Program the hardware with the initial values of everything:
        self.program_static()
\end{python}

\subsubsection{The \texttt{program\_static} method} \label{device_class_program_static}
This is the only method in section \ref{device_class} which can have a different name. The name of this method should correspond to the method named passed into the AO and DO objects instantiated in section \ref{device_class_init}.

This function should be a state machine function, and should call a worker class function to update the device outputs to match the current front panel values.

Below is an example from the pulseblaster code. Here we make use of the \texttt{self.static\_mode} variable to only program changes if we are not currently running a buffered experiment. We pass the values to program in as a dictionary.

\begin{python}
    def get_front_panel_state(self):
        return {'freq0':self.dds_outputs[0].freq.value,
                'amp0':self.dds_outputs[0].amp.value,
                'phase0':self.dds_outputs[0].phase.value,
                'en0':self.dds_outputs[0].gate.state,
                'freq1':self.dds_outputs[1].freq.value,
                'amp1':self.dds_outputs[1].amp.value,
                'phase1':self.dds_outputs[1].phase.value,
                'en1':self.dds_outputs[1].gate.state,
                'flags':''.join(['1' if flag.state else '0' ...
                ... for flag in self.digital_outs]).ljust(12,'0')}
    
    # You must have widget=None as this method is called directly by a gtk widget
    @define_state
    def program_static(self,widget=None):
        # Skip programming if in buffered mode:
        if self.static_mode:
        	# call program_static function in the worker class
            self.queue_work('program_static',self.get_front_panel_state())
\end{python}

\subsubsection{The \texttt{transition\_to\_buffered} method}\label{device_class_transition_to_buffered}
This method is called by the BLACS experiment queue manager, as is designed to program the hardware for a buffered sequence, and place the device in a state ready for execution to begin. The \texttt{transition\_to\_buffered} method is likely to follow the below code almost exactly.
\begin{python}
@define_state
    # This function is given the path to the experiment h5file, and a queue used
    # to notify BLACS when the device is ready for the experiment to start
    def transition_to_buffered(self,h5file,notify_queue):
        self.static_mode = False 
        initial_values = self.get_front_panel_state()
        self.queue_work('program_buffered',h5file,initial_values)
        self.do_after('leave_program_buffered',notify_queue)
\end{python}

The method sets the \texttt{static\_mode} instance variable to False to stop the device being reprogrammed mid experiment if the front panel is modified by the user. This only works if the variable is checked by your \texttt{program\_static} method (see section \ref{device_class_program_static}).

We pass the h5file and front panel values to the \texttt{program\_buffered} method in the worker process, which handles the programming of the device. To avoid output changes upon programming, it is often required to use the front panel values as the first instruction given to the device, and to request that the device remain on this instruction until the device is triggered to start the experiment. Exceptions to this are the NI cards which will not update their outputs until they receive the first clock pulse. Your labscript device class should generate a dummy (or zero valued) instruction as the first instruction in the h5 file, which you can insert the current front panel values into at program time.

Your worker process buffered programming function (above we called it the \texttt{program\_buffered} method) should return the output values of the final instruction. These are automatically passed to the \texttt{leave\_program\_buffered} method in the device class.

The \texttt{leave\_program\_buffered} method will look very similar to this:
\begin{python}
    def leave_program_buffered(self,notify_queue,_results):
        # These are the final values that the device will be in
        # at the end of the run. Store them so that we can use them
        # in transition_to_static:
        self.final_values = _results
        # Notify the queue manager thread that we've finished
        # transitioning to buffered:
        notify_queue.put(self.device_name)
\end{python}

We save the final values so that we can update the front panel when the experiment is over, and notify the BLACS queue manager that the device has finished programming is now ready for the experiment to begin.

\subsubsection{The \texttt{transition\_to\_static} method}\label{device_class_transition_to_static}
The \texttt{transition\_to\_static} method is called by the BLACS queue manager when it has detected that the experiment is over. The purpose of this method is to save any acquired data to the h5file, put the device in a state ready for manual front panel control and update the front panel to reflect the final value of the experiment run.

The method generally follows:
\begin{python}
    @define_state
    def transition_to_static(self,notify_queue):
        # Code to update front panel values to final experiment output state
        
        # Code to place the device in a manual update mode and to
        # save acquired data (usually calls a worker process method)
        
        # Reenable static updates triggered by GTK events
        self.static_mode = True
        # Notify the queue manager that we've finished transitioning to static:
        # If your device needs to save data to the h5 file, only call this after
        # the data has been saved
        notify_queue.put(self.device_name)
\end{python}

To update the front panel values, you should call the \texttt{set\_value} or \texttt{set\_state} methods of the \texttt{AO} or \texttt{DO} objects respectively. It is recommended that you pass \texttt{program=False} to these methods and call the \texttt{static\_update} function of your device class manually. This will make your device ready for the next experiment as quickly as possible as it minimises the number of times we communicate with the worker process, and the number of times we ask the device to be reprogrammed (once only, instead of once per channel).

The queue passed to this method is used as a rudimentary lock for saving data to the experiment h5 file. If your device does not need to access the h5 file at the end of the experiment (which most devices should not unless they have acquired data) you may put the device name in the queue immediately. This will ensure that the transition to static time is as short as possible as devices not accessing the h5 file can transition to static simultaneously. 

If your device does need to access the h5 file, then you can be certain that your device has unobstructed write access to the h5 file until you use the \texttt{notify\_queue}. Generally the saving of data is done in a worker process method, and the \texttt{notify\_queue} is passed to a device class method called after the worker process method has finished. Note that the \texttt{transition\_to\_static} method is not passed the path to the h5 file, and so you need to save it somewhere in your \texttt{transition\_to\_buffered} (or the  associated worker process) method.

\subsubsection{The \texttt{abort\_buffered} method}\label{device_class_abort_buffered}
This method is called when your device has successfully run the \texttt{transition\_to\_buffered} method, but another device has failed the same step. At this point the BLACS queue manager cancels the experiment run and calls the \texttt{abort\_buffered} method. 

This method should place the device back into a working manual mode state. Importantly, the output of the device should not have changed since before \texttt{transition\_to\_buffered} was called, and should not have changed after \texttt{abort\_buffered} has been called.

The method header for this function is as follows:
\begin{python}
    def abort_buffered(self):
\end{python}

The contents of this method varies from device to device. It be as simple as setting \texttt{self.static\_mode = True}, it may call \texttt{transition\_to\_static} (with no notify queue) or be something else entirely.

\subsubsection{The \texttt{destroy} method}\label{device_class_destroy}
The \texttt{destroy} method is called when BLACS is asked to exit. It should place the device is a safe state, set the \texttt{destroy\_complete} instance variable to \texttt{True} and then call the \texttt{close\_tab} method which is defined in the Tab class as does \textbf{not} need overriding. 

It will look something like:
\begin{python}
    @define_state
    def destroy(self):        
        self.queue_work('pb_close')
        self.do_after('leave_destroy')
        
    def leave_destroy(self,_results):
        self.destroy_complete = True
        self.close_tab()
\end{python}

\section{Advanced Features}

\subsection{Device class state machine, callback on timeout}
The state machine architecture of BLACS provides the functionality to register a timeout callback; that is, a method to be called (approximately) every \texttt{n} milliseconds. This is generally used for periodic status monitoring of a device.

To add such a timeout callback to your code, you call from within your device class:
\begin{python}
self.statemachine_timeout_add(delay,self.some_function,userdata1,...)
\end{python}
where userdata1 and following arguments are passed to \texttt{self.some\_function}.

To remove the timeout, call 
\begin{python}
self.timeouts.remove(self.some_function)
\end{python}

Do to the nature of state machines (callbacks are processed one at a time based on the order in the queue), your method is not guaranteed to run as often as you have requested. Initially, because your method is a state machine method, BLACS will add your method to the state machine queue. Once your method has run, it will add a GTK callback to run in \texttt{delay} milliseconds. This GTK callback will queue up your function in the state machine again, and, depending on the length of the queue at that time, may not run immediately. 

\textbf{Also note that you can only have one timeout for a given method. Creating a timeout for the same method will replace the existing timeout.}

\end{document}
