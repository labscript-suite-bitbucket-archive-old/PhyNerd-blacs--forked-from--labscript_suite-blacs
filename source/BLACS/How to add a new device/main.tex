\documentclass[12pt]{article}
\include{pythonlisting}
\usepackage{setspace}
\usepackage[margin=1.5cm]{geometry}


\begin{document}\title{How to add a new device class to BLACS}
\author{Philip Starkey}
\date{\today}
\maketitle
\setstretch{1.2}
\section{Introduction}
This tutorial covers the basics of adding a new device class to BLACS. Existing device classes include the PulseBlaster, NovatechDDS9m, NI PCIe 6363 and NI PCI 6733. These classes are used by BLACS to generate the unique tab for each device on the BLACS front panel. Adding support for your device to BLACS does not add support to labscript, which will also need to be done if you wish to use the device in a buffered sequence (see **TO BE ADDED IN LATER**). If your device is never to be used in a buffered sequence, you may instead wish to implement it as a virtual device (see ** TO BE ADDED IN LATER**).

This tutorial assumes a working knowledge of Python, PyGTK and Glade. If are not familiar with one or more of these, please attempt a tutorial on the subject before continuing with this!

\section{The Glade Interface}\label{glade interface}
The first step is to roughly design the interface for your device in Glade. The design of your interface can be as simple or as complex as you like. 

The backend of BLACS only requires that you conform to one rule for your interface. Anything you want to behave as a digital out should be represented by a widget that can be linked to a GtkAction (this is generally a togglebutton or a checkbox).

Anything you want to behave as an analog out should be represented by a widget that can be linked to a GtkAdjustment (usually a GtkSpinButton) and should have a corresponding GtkComboBox for changing the units of the value shown in the GtkSpinButton.

Also note that internally within BLACS and Labscript, we represent a DDS as a collection of 3 analog outs (one for frequency, amplitude and phase), so it is recommended to follow this pattern when creating an interface for a DDS device. In general, most interfaces can be broken down into a combination of digital outputs (a part of the device with only two states) and analog outputs (a part of the device which can take any value between a maximum and minimum value, often with a particular quantisation).

\textbf{As of Feb 08, 2012, BLACS does not override the GtkSpinButton properties such as \texttt{digits} and \texttt{climb rate}. It will however add it's own GtkAdjustment to the widget, so you are not required to do this yourself in glade. You are also not required to}

\subsection{The GtkComboBox for unit selection}\label{glade unit selection}

\section{Creating the Device Class}\label{creating class}
All device classes as stored in pythonlib/BLACS/hardware\_interfaces. You should create a new file for your device in this folder, with an appropriate name (we shall refer to the name in this tutorial as \texttt{pulseblaster.py}).

The first thing you need to do in your empty python file is import the required packages and classes. The code below imports gtk and the BLACS backend classes for handling various output types. 
The final line imports the BLACS backend for the tab state machine. We'll cover these more as we go.
\begin{python}
import gtk
from output_classes import AO, DO, RF, DDS
from tab_base_classes import Tab, Worker, define_state
\end{python}

Next we need to define two classes. The first class will handle the GUI, and related events. The second will handle the communication with the actual hardware. The first class name (hence forth known as the device class) should match (ignoring case) the device class shown in the entry in the connection table for an instance of your device. You may call the second class (hence forth known as the worker class) whatever you wish, though it is advisable to use something understandable!

In this tutorial we will use \texttt{pulseblaster} and \texttt{PulseblasterWorker} as our class names.

\begin{python}
class pulseblaster(Tab):
    pass
	
class PulseblasterWorker(Worker):
    pass
\end{python}

\textbf{Note:} We have used \texttt{pass} here as a placeholder. You can assume that the \texttt{pass} statements will be removed once the tutorial inserts code at the same indentation level.

\subsection{The Worker Class}
The worker class is used solely to communicated with the hardware for our device. It exists to separate out the code, modules, dll's, etc. from the GUI to provide better stability to the system. The worker class is instantiated inside a separate process (reffered to from now on as the worker process), which can be restarted by the user if the device becomes unresponsive. Upon restart, all libraries are completely reloaded as they are only loaded within the worker process. This allows the system to recover from errors in 3rd party API's without the need to restart the entire control system.

The worker class consists of methods which can be executed by the state machine. In your device class you can call:
\begin{python}
self.queue_work('some_function',arg1,arg2,kwrd1=arg3)
\end{python}
and this will call the function called \texttt{some\_function} with arguments \texttt{arg1,arg2,kwrd1=arg3} in the worker class. This is covered in more detail in ** ADD REF **.


\subsubsection{The \texttt{init} method}
The init method in the worker class is special for two reasons. The first is that it is not called \texttt{\_\_init\_\_} as you would expect. This is because we don't want to override the Worker classes \texttt{\_\_init\_\_} method which is essential for successful operation.

The second is that this is the function in which you import the modules, classes, etc. that you wish to access from within the worker class. They are imported here, within the class, so that they only exist within the worker process, and not within the BLACS process. This allows modules to be completely unloaded from the system when the worker process is restarted. This allows recovery of the programming library without the need to completely restart the program (a technique not seen in any other control system to our knowledge).

If you wish to import a module (for example \texttt{h5py}), use the following code:
\begin{python}
class PulseblasterWorker(Worker):
    def init(self):
        global h5py; import h5py
\end{python}

If you wish to import something from within a module (for example \texttt{spinapi}), you can use:
\begin{python}
        exec 'from spinapi import *' in globals()
\end{python}

You can also set the default values for any class attributes in the \texttt{init} method. For instance:
\begin{python}
        self.smart_cache = {}
\end{python}

If you wish to pass in variables, at instantiation, to your worker class, you can do so, and it is document in ** ADD REF **.

\subsubsection{Worker Class States}
As covered in ** ADD REF ** you can ask the tabs state machine to execute functions within the worker class. These functions can take arguments and keyword arguments as a normal function would, however the arguments must be able to be placed in a Python Queue. Objects with instance methods cannot be placed in a queue, and so can not be passed to a function you wish to call from the state machine.

In general you will have at least 3 functions within your worker class. One to initialise the device, one to handle an update to the devices output in software timed mode (otherwise known as \texttt{static mode}) and one to handle the programming of the device for the hardware timed mode (otherwise known as \texttt{buffered mode}). You may also want functions for exiting the buffered mode (via an abort, or end at the end of the run), checking the status of the device, etc.

Examples of such functions can be seen in any of the existing hardware interface worker classes.

\subsection{The Device Class}\label{device_class}

\subsubsection{The state machine}\label{device_class_state_machine}
The device class contains a state machine which regulates the interprocess communication between the worker process and the GUI process, as well as making sure that the GTK event/signal based architecture is transformed into a deterministic system. 

Most of the state machine architecture is hidden within the \texttt{Tab} class. Any method in the device class prefixed with \texttt{@define\_state} will be queued up appropriately in the state machine. An example is shown below:
\begin{python}
    @define_state
    def start(self,widget=None):
        # some code follows
        time.sleep(5)
\end{python}

Note that if we call this method from within our code, E.g.:
\begin{python}
    def foo(self):
        self.start() # This function call returns immediately
\end{python}
the call to \texttt{start} returns immediately. Some time in the future, the method start will be executed, and the thread will sleep for 5 seconds as expected.

This means that calls to state machine methods (E.g. \texttt{start}) cannot return a parameters in the conventional way. It is expected that state machine methods will be called upon a GTK event (in which case you will never need to return anything from your state) or from another thread (in which case you can use a Python Queue to block the calling thread until your state machine method puts the returns values in the queue)

As mentioned, state machine methods are designed to interact with the worker process. You can call functions within your worker class with the following code:
\begin{python}
    @define_state
    def start(self,widget=None):
        self.queue_work('foo')
\end{python}

If you wish to pass arguments to your method, you can instead call something similar to
\begin{python}
        self.queue_work('foo',1,5,x=3)
\end{python}
It is important to note that you cannot pass objects as arguments to a worker class method. The arguments must be able to be placed into a Python Queue.

Note that the worker process function is not executed until the state machine function ends. Thus in the following example 
\begin{python}
    @define_state
    def start(self,widget=None):
        x = 1
        self.queue_work('foo',x)
        x = 2
        print x
\end{python}
\texttt{'2'} will be printed before the method \texttt{foo} is executed. Since \texttt{x} is an integer, \texttt{foo} will be passed \texttt{'1'} as it's only argument. It is recommended that you call \texttt{self.queue\_work} at the end of your state machine function to avoid confusion.

If you wish to execute some further code once the worker class method has been executed, you can use the \texttt{self.do\_after} method. For example:
\begin{python}
    @define_state
    def start(self,widget=None):
        x = 1
        self.queue_work('foo',x)
        self.do_after('leave_foo',x)
        
    def leave_foo(self,x,_results):
        print x # prints 1
        print _results
\end{python}
The last argument passed to the method called by \texttt{do\_after} is \texttt{\_results} which contains a tuple of values returned by the worker class method called by \texttt{queue\_work}. Note that the method called by \texttt{do\_after} does \textbf{not} have \texttt{@define\_state} written above it's definition.

\subsubsection{The \texttt{\_\_init\_\_} method}\label{device_class_init}

\subsubsection{The \texttt{get\_save\_data} method} \label{device_class_get_save_data}
This function provides an interface for saving tab specific data upon exiting BLACS. The data becomes available to the tab during the \texttt{\_\_init\_\_} method in the \texttt{settings['saved\_data']} variable (see section \ref{device_class_init}).

This method should return a dictionary of data to be saved. The dictionary should satisfy the following condition:
\begin{python}
save_data = {``key'':value} # Dictionary of data to save

eval(repr(save_data)) == save_data # This expression must be true
\end{python}


\subsubsection{The \texttt{program\_static} method} \label{device_class_program_static}
This is the only method in section \ref{device_class} which can have a different name. The name of this method should correspond to the method named passed into the AO and DO objects instantiated in section \ref{device_class_init}.

This function should be a state machine function, and should call a worker class function to update the device outputs to match the current front panel values.

Below is an example from the pulseblaster code. Here we make use of the \texttt{self.static\_mode} variable to only program changes if we are not currently running a buffered experiment. We pass the values to program in as a dictionary.

\begin{python}
    def get_front_panel_state(self):
        return {'freq0':self.dds_outputs[0].freq.value,
                'amp0':self.dds_outputs[0].amp.value,
                'phase0':self.dds_outputs[0].phase.value,
                'en0':self.dds_outputs[0].gate.state,
                'freq1':self.dds_outputs[1].freq.value,
                'amp1':self.dds_outputs[1].amp.value,
                'phase1':self.dds_outputs[1].phase.value,
                'en1':self.dds_outputs[1].gate.state,
                'flags':''.join(['1' if flag.state else '0' ...
                ... for flag in self.digital_outs]).ljust(12,'0')}
    
    # You must have widget=None as this method is called directly by a gtk widget
    @define_state
    def program_static(self,widget=None):
        # Skip programming if in buffered mode:
        if self.static_mode:
        	# call program_static function in the worker class
            self.queue_work('program_static',self.get_front_panel_state())
\end{python}

\subsubsection{The \texttt{transition\_to\_buffered} method}\label{device_class_transition_to_buffered}
This method is called by the BLACS experiment queue manager, as is designed to program the hardware for a buffered sequence, and place the device in a state ready for execution to begin. The \texttt{transition\_to\_buffered} method is likely to follow the below code almost exactly.
\begin{python}
@define_state
    # This function is given the path to the experiment h5file, and a queue used
    # to notify BLACS when the device is ready for the experiment to start
    def transition_to_buffered(self,h5file,notify_queue):
        self.static_mode = False 
        initial_values = self.get_front_panel_state()
        self.queue_work('program_buffered',h5file,initial_values)
        self.do_after('leave_program_buffered',notify_queue)
\end{python}

The method sets the \texttt{static\_mode} instance variable to False to stop the device being reprogrammed mid experiment if the front panel is modified by the user. This only works if the variable is checked by your \texttt{program\_static} method (see section \ref{device_class_program_static}).

We pass the h5file and front panel values to the \texttt{program\_buffered} method in the worker process, which handles the programming of the device. To avoid output changes upon programming, it is often required to use the front panel values as the first instruction given to the device, and to request that the device remain on this instruction until the device is triggered to start the experiment. Exceptions to this are the NI cards which will not update their outputs until they receive the first clock pulse. Your labscript device class should generate a dummy (or zero valued) instruction as the first instruction in the h5 file, which you can insert the current front panel values into at program time.

Your worker process buffered programming function (above we called it the \texttt{program\_buffered} method) should return the output values of the final instruction. These are automatically passed to the \texttt{leave\_program\_buffered} method in the device class.

The \texttt{leave\_program\_buffered} method will look very similar to this:
\begin{python}
    def leave_program_buffered(self,notify_queue,_results):
        # These are the final values that the device will be in
        # at the end of the run. Store them so that we can use them
        # in transition_to_static:
        self.final_values = _results
        # Notify the queue manager thread that we've finished
        # transitioning to buffered:
        notify_queue.put(self.device_name)
\end{python}

We save the final values so that we can update the front panel when the experiment is over, and notify the BLACS queue manager that the device has finished programming is now ready for the experiment to begin.

\subsubsection{The \texttt{transition\_to\_static} method}\label{device_class_transition_to_static}
The \texttt{transition\_to\_static} method is called by the BLACS queue manager when it has detected that the experiment is over. The purpose of this method is to save any acquired data to the h5file, put the device in a state ready for manual front panel control and update the front panel to reflect the final value of the experiment run.

The method generally follows:
\begin{python}
    @define_state
    def transition_to_static(self,notify_queue):
        # Code to update front panel values to final experiment output state
        
        # Code to place the device in a manual update mode and to
        # save acquired data (usually calls a worker process method)
        
        # Reenable static updates triggered by GTK events
        self.static_mode = True
        # Notify the queue manager that we've finished transitioning to static:
        # If your device needs to save data to the h5 file, only call this after
        # the data has been saved
        notify_queue.put(self.device_name)
\end{python}

The queue passed to this method is used as a rudimentary lock for saving data to the experiment h5 file. If your device does not need to access the h5 file at the end of the experiment (which most devices should not unless they have acquired data) you may put the device name in the queue immediately. This will ensure that the transition to static time is as short as possible as devices not accessing the h5 file can transition to static simultaneously. 

If your device does need to access the h5 file, then you can be certain that your device has unobstructed write access to the h5 file until you use the \texttt{notify\_queue}. Generally the saving of data is done in a worker process method, and the \texttt{notify\_queue} is passed to a device class method called after the worker process method has finished. Note that the \texttt{transition\_to\_static} method is not passed the path to the h5 file, and so you need to save it somewhere in your \texttt{transition\_to\_buffered} (or the  associated worker process) method.

\subsubsection{The \texttt{abort\_buffered} method}\label{device_class_abort_buffered}
This method is called when your device has successfully run the \texttt{transition\_to\_buffered} method, but another device has failed the same step. At this point the BLACS queue manager cancels the experiment run and calls the \texttt{abort\_buffered} method. 

This method should place the device back into a working manual mode state. Importantly, the output of the device should not have changed since before \texttt{transition\_to\_buffered} was called, and should not have changed after \texttt{abort\_buffered} has been called.

The method header for this function is as follows:
\begin{python}
    def abort_buffered(self):
\end{python}

The contents of this method varies from device to device. It be as simple as setting \texttt{self.static\_mode = True}, it may call \texttt{transition\_to\_static} (with no notify queue) or be something else entirely.

\subsubsection{The \texttt{destroy} method}\label{device_class_destroy}
The \texttt{destroy} method is called when BLACS is asked to exit. It should place the device is a safe state, set the \texttt{destroy\_complete} instance variable to \texttt{True} and then call the \texttt{close\_tab} method which is defined in the Tab class as does \textbf{not} need overriding. 

It will look something like:
\begin{python}
    @define_state
    def destroy(self):        
        self.queue_work('pb_close')
        self.do_after('leave_destroy')
        
    def leave_destroy(self,_results):
        self.destroy_complete = True
        self.close_tab()
\end{python}

\section{Advanced Features}

\end{document}